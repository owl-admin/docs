"use strict";(self.webpackChunkrspress_doc_template=self.webpackChunkrspress_doc_template||[]).push([["3329"],{7701:function(e,n,s){s.r(n),s.d(n,{default:function(){return d}});var r=s(2676),i=s(453);function c(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",ul:"ul",li:"li",code:"code",div:"div",p:"p",pre:"pre"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"框架原理",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#框架原理",children:"#"}),"框架原理"]}),"\n",(0,r.jsxs)(n.h2,{id:"运行流程",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#运行流程",children:"#"}),"运行流程"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["用户访问到 ",(0,r.jsx)(n.code,{children:"/public/admin"})," 下的静态文件, 前端程序会自动请求框架信息, 比如 路由, 配置, 用户信息等"]}),"\n",(0,r.jsxs)(n.li,{children:["前端程序会根据路由配置, 访问到对应的页面 (默认的页面都是 ",(0,r.jsx)(n.code,{children:"Amis"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["在 ",(0,r.jsx)(n.code,{children:"Amis"})," 页面中, 会根据路由的路径, 请求对应的 ",(0,r.jsx)(n.code,{children:"api"})," 从而获取到 ",(0,r.jsx)(n.code,{children:"amis"})," 的页面结构"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"amis"})," 会根据页面结构, 渲染出页面"]}),"\n"]}),"\n",(0,r.jsxs)(n.div,{className:"rspress-directive info",children:[(0,r.jsx)(n.div,{className:"rspress-directive-title",children:"请求流程"}),(0,r.jsx)(n.div,{className:"rspress-directive-content",children:(0,r.jsx)(n.p,{children:"\n访问前端 → 获取路由 → 获取页面结构 → 渲染页面"})})]}),"\n",(0,r.jsxs)(n.h2,{id:"renderer-类的工作原理",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#renderer-类的工作原理",children:"#"}),"Renderer 类的工作原理"]}),"\n",(0,r.jsxs)(n.p,{children:["所有的 ",(0,r.jsx)(n.code,{children:"Renderer"})," 都继承了 ",(0,r.jsx)(n.code,{children:"BaseRenderer"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",meta:"",children:"<?php\n\nnamespace Slowlyo\\OwlAdmin\\Renderers;\n\n// BaseRenderer 实现了 JsonSerializable 接口\n// JsonSerializable 接口的作用是, 当 Renderer 类 被序列化成 JSON, 会自动调用 jsonSerialize() 方法\n// 文档: https://www.php.net/manual/zh/class.jsonserializable.php\nclass BaseRenderer implements \\JsonSerializable\n{\n    public string $type;\n\n    // 这个属性用于存储页面结构\n    public array $amisSchema = [];\n\n    // make() 方法是一个静态方法, 用于创建一个新的 Renderer 实例\n    // 作用: 为了方便使用, 你可以直接使用 Renderer::make() 来创建一个新的 Renderer 实例, 而不需要使用 new Renderer()\n    public static function make(): static\n    {\n        return new static();\n    }\n\n    // 通过魔术方法, 实现对 '不存在的方法' 的调用\n    public function __call($name, $arguments)\n    {\n        return $this->set($name, array_shift($arguments));\n    }\n\n    // 将属性存储到 $amisSchema 中, 并返回当前实例, 以便于链式调用\n    public function set($name, $value)\n    {\n        $this->amisSchema[$name] = $value;\n\n        return $this;\n    }\n\n    // 当你在控制器中, 使用 $this->response()->success($schema);\n    // 将结构返回给前端时, 会自动调用这个方法~\n    public function jsonSerialize()\n    {\n        return $this->filteredResults(); // 返回过滤后的页面结构\n    }\n\n    // 返回 json 格式的页面结构\n    public function toJson(): bool|string\n    {\n        return json_encode($this->amisSchema);\n    }\n\n    // 返回数组格式的页面结构\n    public function toArray(): array\n    {\n        return $this->amisSchema;\n    }\n\n    // 因为所有的 Renderer 都继承了 BaseRenderer, 所以这个方法会被所有的 Renderer 继承\n    // 等同于给所有的 Renderer 添加了一个 permission() 方法\n    // 或者说, 给所有的 amis 组件都添加了一个 permission 属性\n    public function permission($permission)\n    {\n        $this->amisSchema['owl_permission'] = $permission;\n\n        return $this;\n    }\n\n    // 过滤掉没有权限的页面结构\n    public function filteredResults()\n    {\n        $permissionKey = 'owl_permission';\n\n        if (key_exists($permissionKey, $this->amisSchema)) {\n            if (!admin_user()->can($this->amisSchema[$permissionKey])) {\n                return null;\n            }\n        }\n\n        return $this->amisSchema;\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这个类其实就是整个 ",(0,r.jsx)(n.code,{children:"owl"})," 的精华所在"]}),"\n",(0,r.jsxs)(n.p,{children:["在了解了 ",(0,r.jsx)(n.code,{children:"Renderer"})," 的原理之后, 只需要把 ",(0,r.jsx)(n.code,{children:"amis"})," 的 100 多个组件稍微封装一下, 就可以实现 ",(0,r.jsx)(n.code,{children:"amis"})," 的所有功能了"]}),"\n",(0,r.jsxs)(n.p,{children:["也就是 ",(0,r.jsx)(n.code,{children:"vendor/slowlyo/owl-admin/src/Renderers"})," 目录下的那 200 多个文件"]}),"\n",(0,r.jsx)(n.p,{children:"是不是很简单呢? \uD83D\uDE0F"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(c,e)})):c(e)}let d=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["guide%2Fbasic%2Fframe.md"]={toc:[{id:"运行流程",text:"运行流程",depth:2},{id:"renderer-类的工作原理",text:"Renderer 类的工作原理",depth:2}],title:"框架原理",frontmatter:{}}}}]);